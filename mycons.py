import numpy as np
import math


def atand(x):
    return np.arctan(x) * 180 / np.pi


def sind(x):
    return np.sin(x * np.pi / 180)


def cosd(x):
    return np.cos(x * np.pi / 180)

## kconstants（角频率、天文初位相、订正角、交点因子）调和常数计算
def kconstants(cons):
    ## 杜德森数
    ## 13分潮
    k = np.array([[2, -2, 2, 0, 0, 0],  # km2 -----%半日
                  [2, 0, 0, 0, 0, 0],  # ks2
                  [2, -3, 2, 1, 0, 0],  # kn2
                  [2, 0, 2, 0, 0, 0],  # kk2
                  [1, 0, 1, 0, 0, 90],  # kk1 -----%全日
                  [1, -2, 1, 0, 0, 270],  # ko1
                  [1, 0, -1, 0, 0, 270],  # kp1
                  [1, -3, 1, 1, 0, 270],  # kq1
                  [4, -4, 4, 0, 0, 0],  # km4 -----%浅水
                  [4, -2, 2, 0, 0, 0],  # kms4
                  [6, -6, 6, 0, 0, 0],  # km6
                  [0, 0, 1, 0, 0, 0],  # ksa -----%长周期
                  [0, 0, 2, 0, 0, 0]])  # kssa

    ## 天文参数
    n = cons[0];
    Y = cons[1];
    L = 0
    for i in range(1900, Y):  # 1900年至*年的所有闰年
        if i % 4 == 0 and i % 100 != 0 or i % 400 == 0:
            L += 1
    D1 = 0;
    t = np.linspace(0, n - 1, n, endpoint=True, dtype=int).reshape(1, n)
    # --------------------------------------------------------------------------------------------------------------------
    # 平太阳时角t和月球、太阳、月球近地点、太阳近地点的平均经度
    # D1为Y年1月1日开始，L为1900年至Y年的闰年数
    t = 180
    s = 277.025 + 129.38481 * (Y - 1900) + 13.1764 * (D1 + L + t / 24) #月球 回归月
    h = 280.190 - 0.23872 * (Y - 1900) + 0.98565 * (D1 + L + t / 24) #太阳 回归年
    p = 334.385 + 40.66249 * (Y - 1900) - 0.11140 * (D1 + L + t / 24) #月球近地点 8.85年
    N = 259.157 - 19.32818 * (Y - 1900) + 0.05295 * (D1 + L + t / 24) #升交点 18.61年
    ps = 281.221 + 0.01718 * (Y - 1900) + 0.000047 * (D1 + L + t / 24) #太阳近地点
    # --------------------------------------------------------------------------------------------------------------------
    # 每太阳日和平太阳时的角度变化
    ST = 15; #360/24
    Si = 14.49205211; #360/24.8412
    Ss = 0.54901653; #360/(27.32158*24)
    Sh = 0.04106864; #360/(365.2422*24)
    Sp = 0.00464183; #360/(8.84732*365.25*24)
    SN = 0.00220641; #360/(18.6129*365.25*24)
    Sps = 0.000001961; #360/(20940*365.25*24)
    Sigma = np.zeros((1, 13))
    V0 = np.zeros((1, 13))
    ## Sigma and V0
    for i in range(13):
        # Sigma是分潮的角速度
        Sigma[0, i] = k[i, 0] * ST + k[i, 1] * Ss + k[i, 2] * Sh + k[i, 3] * Sp + k[i, 4] * Sps
        # V0是天文初位相
        V0[0, i] = k[i, 1] * s[:, 0] + k[i, 2] * h[:, 0] + k[i, 3] * p[:, 0] + k[i, 4] * ps[:, 0] + k[i, 5]

    # -----------------------------------------------------------------------------------------------------------------
    # M2
    A1 = 1 - 0.03733 * cosd(N) + 0.00052 * cosd(2 * N) + 0.00058 * cosd(2 * p) + 0.00021 * cosd(2 * p - N)
    B1 = -0.03733 * sind(N) + 0.00052 * sind(2 * N) + 0.00058 * sind(2 * p) + 0.00021 * sind(2 * p - N)
    # S2
    A2 = 1 + 0.00225 * cosd(N) + 0.00014 * cosd(2 * p)
    B2 = 0.00225 * sind(N) + 0.00014 * sind(2 * p)
    # N2
    A3 = 1 - 0.03733 * cosd(N) + 0.00052 * cosd(2 * N) + 0.00081 * cosd(p - ps) - 0.00385 * cosd(2 * p - 2 * N)
    B3 = -0.03733 * sind(N) + 0.00052 * sind(2 * N) - 0.00081 * sind(p - ps) + 0.00385 * sind(2 * p - 2 * N)
    # K2
    A4 = 1 + 0.28518 * cosd(N) + 0.03235 * cosd(2 * N)
    B4 = -0.31074 * sind(N) - 0.03235 * sind(2 * N)
    # %K1
    A5 = 1 + 0.11573 * cosd(N) - 0.00281 * cosd(2 * N) + 0.00019 * cosd(2 * p - N)
    B5 = -0.15539 * sind(N) + 0.00303 * sind(2 * N) - 0.00019 * sind(2 * p - N)
    # O1
    A6 = 1 + 0.18852 * cosd(N) - 0.00578 * cosd(2 * N) - 0.00645 * cosd(2 * p) - 0.00103 * cosd(
        2 * p - N) + 0.00019 * cosd(2 * p + N)
    B6 = 0.18852 * sind(N) - 0.00578 * sind(2 * N) - 0.00645 * sind(2 * p) - 0.00103 * sind(2 * p - N) + 0.00019 * sind(
        2 * p + N)
    # P1
    A7 = 1 - 0.01123 * cosd(N) + 0.00080 * cosd(2 * N) - 0.00040 * cosd(2 * ps) - 0.00148 * cosd(
        2 * p) - 0.00029 * cosd(2 * p - N)
    B7 = -0.01123 * sind(N) + 0.00080 * sind(2 * N) - 0.00040 * sind(2 * ps) - 0.00148 * sind(2 * p) - 0.00029 * sind(
        2 * p - N)
    # Q1
    A8 = 1 + 0.18844 * cosd(N) - 0.00568 * cosd(2 * N) - 0.00277 * cosd(2 * p) - 0.00388 * cosd(
        2 * p - 2 * N) + 0.00083 * cosd(p - ps) - 0.00069 * cosd(2 * p - 3 * N)
    B8 = 0.18844 * sind(N) - 0.00568 * sind(2 * N) - 0.00277 * sind(2 * p) + 0.00388 * sind(
        2 * p - 2 * N) - 0.00083 * sind(p - ps) + 0.00069 * sind(2 * p - 3 * N)
    A0 = np.concatenate((A1, A2, A3, A4, A5, A6, A7, A8), axis=0)
    B0 = np.concatenate((B1, B2, B3, B4, B5, B6, B7, B8), axis=0)
    ## f and u
    # f交点因子和 u订正角
    f = np.sqrt(A0 * A0 + B0 * B0)
    u = atand(B0 / A0)
    # M4
    f9 = f[0] * f[0].reshape(1, n);
    u9 = 2 * u[0].reshape(1, n)
    # MS4
    f10 = f[0] * f[1].reshape(1, n);
    u10 = u[0] + u[1].reshape(1, n)
    # M6
    f11 = f[0] * f[0] * f[0].reshape(1, n);
    u11 = 3 * u[0].reshape(1, n)
    # Sa
    f12 = np.ones((1, n)).reshape(1, n);
    u12 = np.zeros((1, n)).reshape(1, n)
    # Ssa
    f13 = np.ones((1, n)).reshape(1, n);
    u13 = np.zeros((1, n)).reshape(1, n)
    # --------------------------------------------------------------------------------------------------------------------
    f = np.concatenate((f, f9, f10, f11, f12, f13), axis=0)
    u = np.concatenate((u, u9, u10, u11, u12, u13), axis=0)  # 订正角
    f = f.T;
    u = u.T;
    return Sigma, V0, u, f

if __name__ == "__main__":
    pass


